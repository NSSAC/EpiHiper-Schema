#!/usr/bin/env node

// BEGIN: Copyright
// Copyright (C) 2019 Rector and Visitors of the University of Virginia
// All rights reserved
// END: Copyright

// BEGIN: License
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// END: License

const pkg = require('../package.json');
const cfg = require('../config.json');
const commander = require('commander');
const Ajv = require('ajv');
const path = require('path');

let files;

commander
    .version(pkg.version)
    .description('EpiHiper Schema Validation')
    .usage('[options] <file ...>')
    .option('--no-default', 'Do not add defaults for missing values')
    .option('--recursive', 'Process files referenced in run parameters')
    .arguments('<files...>')
    .action(function(_files) {
      files = _files;
    });

commander.parse(process.argv);

if (!Array.isArray(files)) {
  commander.help();
  process.exit(1);
}

const currDir = process.cwd();
const ajv = new Ajv({schemaId: 'auto'});
ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'));

cfg.schema.forEach(function(s) {
  const sInstance = require(path.join(__dirname, '..', 'schema', s));
  sInstance['$id'] = 'file://./' + s;
  ajv.addSchema(sInstance);
});

const merged = {};
merged.diseaseModel = {};
merged.sets = [];
merged.globalVariables = [];
merged.initialization = [];
merged.interventions = [];
merged.traits = [];
merged.personTraitDBs = [];
merged.runParameters = {};

files.forEach(function(file) {
  const InstanceFile = path.join(currDir, file);
  process.stdout.write('File: ' + InstanceFile);
  const Instance = require(InstanceFile);

  const SchemaRelDir = path.dirname(InstanceFile);
  const SchemaFile = path.join(SchemaRelDir, Instance['$schema']);

  const Id = 'file://' + SchemaFile.replace(path.join(__dirname, '..', 'schema'), '.');
  // Check whether we have the schema already loaded

  const validate = ajv.getSchema(Id);

  if (typeof validate === 'undefined') {
    throw new Error('Schema: ' + SchemaFile + ' invalid');
  }

  const valid = validate(Instance);

  if (!valid) {
    console.log(' invalid');
    console.log(validate.errors);
    return;
  } else {
    console.log(' valid');
  }

  switch (path.basename(Id)) {
    case 'diseaseModelSchema.json':
      addDiseaseModel(Instance);
      break;

    case 'initializationSchema.json':
      addSets(Instance.sets);
      addInitializations(Instance.initializations);
      break;

    case 'interventionSchema.json':
      addSets(Instance.sets);
      addGlobalVariables(Instance.globalVariables);
      addInterventions(Instance.interventions);
      break;

    case 'interventionTemplateSchema.json':
      break;

    case 'mergedSchema.json':
      addDiseaseModel(Instance.diseaseModel);
      addSets(Instance.sets);
      addGlobalVariables(Instance.globalVariables);
      addInitializations(Instance.initializations);
      addInterventions(Instance.interventions);
      addTraits(Instance.traits);
      addPersonTraitDBs(Instance.personTraitDBs);
      addRunParameters(Instance.runParameters);
      break;

    case 'personTraitDBSchema.json':
      addPersonTraitDBs([Instance]);
      break;

    case 'runParametersSchema.json':
      addRunParameters(Instance);
      break;

    case 'traitsSchema.json':
      addTraits(Instance.traits);
      break;

    case 'typeRegistry.json':
      break;

    case 'personTraitDB/schemas/tabular-data-resource.json':
      break;

    case 'personTraitDB/schemas/dictionary.json':
      break;
  }
});

process.stdout.write('Merged Instance');
validate = ajv.getSchema('file://./mergedSchema.json');

valid = validate(merged);

if (!valid) {
  console.log(' invalid');
  console.log(validate.errors);
} else {
  console.log(' valid');
}

console.log(merged);

process.exit(0);

/**
 * Check whether the given object is empty.
 * @param {object} obj
 * @return {Boolean} isEmpty
 */
function isEmpty(obj) {
  return (Object.keys(obj).length === 0 && obj.constructor === Object);
}
/**
 * Adds the disease model to the merged EpiHiper input.
 * @param {object} diseaseModel
 * @return {void}
 */
function addDiseaseModel(diseaseModel) {
  if (typeof diseaseModel === 'undefined') return;

  if (! isEmpty(merged.diseaseModel)) {
    throw new Error('Merging of disease model is not supported.');
  }

  merged.diseaseModel = diseaseModel;
};

/**
 * Adds sets to the merged EpiHiper input.
 * @param {object} sets
 * @return {void}
 */
function addSets(sets) {
  if (!Array.isArray(sets)) return;

  sets.forEach(function(set) {
    merged.sets.push(set);
  });
};

/**
 * Adds gobalVariables to the merged EpiHiper input.
 * @param {object} gobalVariables
 * @return {void}
 */
function addGlobalVariables(gobalVariables) {
  if (!Array.isArray(gobalVariables)) return;

  gobalVariables.forEach(function(gobalVariable) {
    merged.gobalVariables.push(gobalVariable);
  });
};

/**
 * Adds initializations to the merged EpiHiper input.
 * @param {object} initializations
 * @return {void}
 */
function addInitializations(initializations) {
  if (!Array.isArray(initializations)) return;

  initializations.forEach(function(initialization) {
    merged.initializations.push(initialization);
  });
};

/**
 * Adds interventions to the merged EpiHiper input.
 * @param {object} interventions
 * @return {void}
 */
function addInterventions(interventions) {
  if (!Array.isArray(interventions)) return;

  interventions.forEach(function(intervention) {
    merged.interventions.push(intervention);
  });
};

/**
 * Adds traits to the merged EpiHiper input.
 * @param {object} traits
 * @return {void}
 */
function addTraits(traits) {
  if (!Array.isArray(traits)) return;

  traits.forEach(function(trait) {
    merged.traits.push(trait);
  });
};

/**
 * Adds personTraitDBs to the merged EpiHiper input.
 * @param {object} personTraitDBs
 * @return {void}
 */
function addPersonTraitDBs(personTraitDBs) {
  if (!Array.isArray(personTraitDBs)) return;

  personTraitDBs.forEach(function(personTraitDB) {
    merged.personTraitDBs.push(personTraitDB);
  });
};

/**
 * Adds the run parameters to the merged EpiHiper input.
 * @param {object} runParameters
 * @return {void}
 */
function addRunParameters(runParameters) {
  if (typeof runParameters === 'undefined') return;

  if (! isEmpty(merged.runParameters)) {
    throw new Error('Merging of run parameters is not supported.');
  }

  merged.runParameters = runParameters;
};
